# C++学习

## 成员变量(Field)

1. 作用域是类的作用域，在类的方法里面可以直接使用。本地变量在方法内定义，只能在方法内使用。
2. 若本地变量和成员变量的名字相同，则遵循就近原则，及该名字代表本地变量。
3. `this`:隐藏的参数，指向调用该方法的对象。

## 构造函数(Constructor)

1. 名字与类相同。
2. 没有返回类型。
3. 在创建对象时就会被调用。
4. 默认构造函数：没有参数的构造函数。

## 析构函数(Destructor)

1. 对象被清除的时候调用。
2. 析构函数不能有参数。
3. 如果类中有成员变量是用new构造的，则在析构函数中用delete清除。

## 动态内存分配

1. new 申请一块空间，并调用该对象的构造函数。结果为指向该空间的指针。
2. delete 销毁这块空间。
3. 申请时带有方括号`[]`，则销毁时也要方括号。

## 访问限制

1. private: 只能由该类中的函数、其友元函数访问,不能被任何其他访问，该类的对象也不能访问。
2. protected: 可以被该类中的函数、子类的函数、以及其友元函数访问，但不能被该类的对象访问。
3. public: 可以被该类中的函数、子类的函数、其友元函数访问，也可以由该类的对象访问。
4. class和struct基本是一样的，仅有差别：没有声明访问权限的情况下，class默认为private，struct默认为public。C++尽量用class。

## 友元(Friend)

1. 友元可以访问该类的私有成员变量。
2. 友元可以是全局函数，其他类，其他类的函数。

## 初始化列表(Initialized List)

1. 初始化列表早于构造函数。
2. 建议：类里所有的成员变量在初始化列表里面初始化，而不是在构造函数里面赋值。
3. 对象要在初始化列表里进行初始化，否则则需要该对象有默认构造函数。
4. 父类的初始化构造函数也必须放在这里。
5. 初始化的顺序是成员变量在声明里的顺序，而不是初始化列表里的顺序。父类是会首先被构造的。

## 对象组成(Composite)

1. 对象可以包含一个另一个对象，或该对象的指针。（根据语义区别处理）
2. 对象在初始化列表里面，通过调用其构造函数进行初始化。

## 继承(Inheritance)

1. 子类继承父类后，拥有父类的所有东西，包括构造函数和析构函数。
2. 不能直接操作父类私有对象，通过父类public方法操作。子类可以访问父类的protected方法，但子类的对象不可以。
3. 成员变量尽量private，可以用protected的接口将成员变量提供给子类访问。
4. 父类比子类先构造，比子类后析构。
5. 如果父类中有重载的函数，且子类有同名的函数，则父类中的所有同名重载函数都被隐藏了。

## 重载(Overload)

1. 函数的名字相同，参数表不同，则构成重载。
2. 函数的参数表相同，但返回类型不一样不能构成重载。

## 函数缺省参数值(Default argument)

1. 函数的缺省参数必须在参数表的最右边。
2. 缺省参数必须卸载函数原型里面，而不能写在定义里面。
3. 尽量不要用缺省值，因为会造成阅读上的困难。

## 内联函数(inline)

1. 把函数之间插入调用的地方，从而减少调用的开销。
2. 内联函数在声明和定义处都要声明。
3. 类的成员函数如果在声明时就定义了，则都是内联函数。
4. 编译器会因函数过大等因素而拒绝内联。递归的函数不能inline。
5. 可以在类的声明后面定义成员函数，并声明为inline。
6. 比较小的函数（2到3行），或频繁调用（如循环）的函数值得被设位inline。

>在进入某个区块（如函数或大括号包含的区域）的时候，编译器就会为该区块分配好内存（堆栈）空间。
>因此声明数组必须要知道具体的长度，所以要求数组长度是个常量，或编译时已知数值的const int。

## Const

1. `char * const p = "abc";`表示指针p是`const`，指针不能修改。
2. `const char * p = "abc";`表示不能通过这个指针来修改对象。
3. `char *p = "abc";`不能使用这种语句，因为`"abc"`是存在代码段里面的`const char *`，是不能修改的，可以写成
    `char p[] = "abc";`，这样`"abc"`会被拷贝到堆栈中。
4. 对象前添加`const`则对象所有成员变量都不能修改，因此不要这么做。
5. 在成员函数后面添加`const`，保证该成员函数不会修改任何成员变量。在原型和定义的地方都需要加`const`。
6. `const`加在成员函数后面可视为修饰`this`指针，同名且参数表相同的成员函数，其中一个带`const`，可以构成重载，因为
    参数`this`不一样，调用时根据对象是否`const`来区分调用的是哪个。

## 引用(Reference)

1. `type& refname = name;`引用一般要在定义的时候初始化，name必须为变量，或左值。refname是name的别名(alias)。
2. `type& refname`这种没有初始化的表达式可以出现在参数表（参数传递时初始化），和成员变量（构造时初始化）中。
3. 引用绑定后时不能改变的，指针可以改变。
4. 函数的返回值如果是引用，则可以做左值，如`h() = 16;`，指针也可以，如`*k() = 16;`。
5. 同名函数，参数表只有有引用和无引用的差别，是不能重载的。
