# C++学习

## 成员变量(Field)

1. 作用域是类的作用域，在类的方法里面可以直接使用。本地变量在方法内定义，只能在方法内使用。
2. 若本地变量和成员变量的名字相同，则遵循就近原则，及该名字代表本地变量。
3. `this`:隐藏的参数，指向调用该方法的对象。

## 构造函数(Constructor)

1. 名字与类相同。
2. 没有返回类型。
3. 在创建对象时就会被调用。
4. 默认构造函数：没有参数的构造函数。

## 析构函数(Destructor)

1. 对象被清除的时候调用。
2. 析构函数不能有参数。
3. 如果类中有成员变量是用new构造的，则在析构函数中用delete清除。

## 动态内存分配

1. new 申请一块空间，并调用该对象的构造函数。结果为指向该空间的指针。
2. delete 销毁这块空间。
3. 申请时带有方括号`[]`，则销毁时也要方括号。

## 访问限制

1. private: 只能由该类中的函数、其友元函数访问,不能被任何其他访问，该类的对象不能在类的外部访问。
2. protected: 可以被该类中的函数、子类的函数、以及其友元函数访问，但不能被该类的对象访问。
3. public: 可以被该类中的函数、子类的函数、其友元函数访问，也可以由该类的对象访问。
4. class和struct基本是一样的，仅有差别：没有声明访问权限的情况下，class默认为private，struct默认为public。C++尽量用class。

## 友元(Friend)

1. 友元可以访问该类的私有成员变量。
2. 友元可以是全局函数，其他类，其他类的函数。

## 初始化列表(Initialized List)

1. 初始化列表早于构造函数。
2. 建议：类里所有的成员变量在初始化列表里面初始化，而不是在构造函数里面赋值。
3. 对象要在初始化列表里进行初始化，否则则需要该对象有默认构造函数。
4. 父类的初始化构造函数也必须放在这里。
5. 初始化的顺序是成员变量在声明里的顺序，而不是初始化列表里的顺序。父类是会首先被构造的。

## 对象组成(Composite)

1. 对象可以包含一个另一个对象，或该对象的指针。（根据语义区别处理）
2. 对象在初始化列表里面，通过调用其构造函数进行初始化。

## 继承(Inheritance)

1. 子类继承父类后，拥有父类的所有东西，包括构造函数和析构函数。
2. 不能直接操作父类私有对象，通过父类public方法操作。子类可以访问父类的protected方法，但子类的对象不可以。
3. 成员变量尽量private，可以用protected的接口将成员变量提供给子类访问。
4. 父类比子类先构造，比子类后析构。
5. 如果父类中有重载的函数，且子类有同名的函数，则父类中的所有同名重载函数都被隐藏了。

## 重载(Overload)

1. 函数的名字相同，参数表不同，则构成重载。
2. 函数的参数表相同，但返回类型不一样不能构成重载。

## 函数缺省参数值(Default argument)

1. 函数的缺省参数必须在参数表的最右边。
2. 缺省参数必须卸载函数原型里面，而不能写在定义里面。
3. 尽量不要用缺省值，因为会造成阅读上的困难。

## 内联函数(inline)

1. 把函数之间插入调用的地方，从而减少调用的开销。
2. 内联函数在声明和定义处都要声明。
3. 类的成员函数如果在声明时就定义了，则都是内联函数。
4. 编译器会因函数过大等因素而拒绝内联。递归的函数不能inline。
5. 可以在类的声明后面定义成员函数，并声明为inline。
6. 比较小的函数（2到3行），或频繁调用（如循环）的函数值得被设位inline。

>在进入某个区块（如函数或大括号包含的区域）的时候，编译器就会为该区块分配好内存（堆栈）空间。
>因此声明数组必须要知道具体的长度，所以要求数组长度是个常量，或编译时已知数值的const int。

## Const

1. `char * const p = "abc";`表示指针p是`const`，指针不能修改。
2. `const char * p = "abc";`表示不能通过这个指针来修改对象。
3. `char *p = "abc";`不能使用这种语句，因为`"abc"`是存在代码段里面的`const char *`，是不能修改的，可以写成
    `char p[] = "abc";`，这样`"abc"`会被拷贝到堆栈中。
4. 对象前添加`const`则对象所有成员变量都不能修改，因此不要这么做。
5. 在成员函数后面添加`const`，保证该成员函数不会修改任何成员变量。在原型和定义的地方都需要加`const`。
6. `const`加在成员函数后面可视为修饰`this`指针，同名且参数表相同的成员函数，其中一个带`const`，可以构成重载，因为
    参数`this`不一样，调用时根据对象是否`const`来区分调用的是哪个。

## 引用(Reference)

1. `type& refname = name;`引用一般要在定义的时候初始化，name必须为变量，或左值。refname是name的别名(alias)。
2. `type& refname`这种没有初始化的表达式可以出现在参数表（参数传递时初始化），和成员变量（构造时初始化）中。
3. 引用绑定后时不能改变的，指针可以改变。
4. 函数的返回值如果是引用，则可以做左值，如`h() = 16;`，指针也可以，如`*k() = 16;`。
5. 同名函数，参数表只有有引用和无引用的差别，是不能重载的。
6. 传对象给函数时，可以将`const type&`传给函数，避免传对象时大量的数据传递，以及传递指针时出现大量`*`号。

## 多态(Polymorphism)

1. 向上造型，把子类的对象当作父类的对象看待，如可以将子类的对象地址赋给父类的指针，这样是安全的，因为子类包含父类所有的
    东西，父类可以进行的操作，子类也都可以。
2. 动态绑定，到运行的时候，根据指针指向的对象类型来绑定调用的函数。静态绑定：编译时就已经确定好了调用的函数。
3. 成员函数是`virtual`的，则会产生动态绑定。
4. 所有有`virtual`函数的类的对象里面最头上会自动加上一个指针`vptr`，指向`vtable`虚函数表。这张表属于整个类。
5. 将子类赋值给父类的时候，`vptr`是没有变的。
6. 如果类里有至少一个`virtual`函数，那么析构函数必须是`virtual`的。在动态创建内存(new)，且使用了多态特性的时候，析构函数(delete)
    也必须是动态绑定的，否则只会调用基类的析构。
7. 派生类和基类有同名的`virtual`时，称为覆盖或改写(override)。如果构成了override，则派生类调用基类的同名函数要用`Base::func()`的形式。

## 拷贝构造

>重点注意：初始化(initializing)和赋值(assignment)之间的区别。

1. C++中`i(0)`和`i = 0`这样的赋值语句是一样的，所以对象初始化的时候也可以写成`A a = 0;`的形式，本质上都是调用A的构造函数来构造a。
2. 对象在初始化的时候，总是要调用构造函数，没有参数初始化时就会调用默认（无参）构造函数，有参数调用时就会调用对应的构造函数，而用别的对象来
    进行初始化时，则需要类有一个以对象作为参数的构造函数，形式为`A::A(const A&)`，称为拷贝构造，要用到引用，因为如果没有引用，构造函数在
    调用的时候形参为另一个对象，那么又需要对这个形参进行构造，相当于进入了一个没有出口的递归。
3. 如果使用了用对象来初始化另一个对象的方法，又没有声明拷贝构造函数，那么编译器会自动生成一个。
4. 如果自己定义了拷贝构造，那么可以自己控制如何拷贝，如果使用编译器生成的拷贝构造，那么会将每一个成员变量进行拷贝。
5. 对象里如果有指针，那么拷贝后两个对象的指针指向同一地址，容易出现错误。
6. 拷贝构造调用：①使用对象来初始化对象，②函数参数为一个对象，③函数返回一个对象。

>翁恺老师建议：写一个类，就把类的三个函数写出来：默认构造，拷贝构造，虚析构函数。
>如果不希望对象作为函数的参数，可以把拷贝构造设位`private`，这样直接禁用拷贝构造。

## 静态(Static)

>C中的`static`有两种用法，静态全局变量：变量只在这个.c文件里面有效，静态本地变量：这个变量具有持久存储(Persistent storage)。

1. 静态本地对象：C++保证对象只会被初始化一次。
2. 全局对象的构造函数调用在`main()`函数之前。
3. 不同文件中对象的初始化顺序是不确定的，所以不要在多个文件中定义全局对象。
4. 如果类有静态的成员变量，那么一定要有对应的.cpp文件，因为.h里的static只是声明，并没有定义。
5. 静态的成员只能在定义的地方初始化，所以不能在初始化列表里初始化静态变量。
6. 静态成员函数可以用`Class::func()`的方法调用，由于调用可以不需要对象，因此没有`this`指针，所以静态的函数只能访问静态的成员变量。

## 运算符重载(Overloaded Operators)

1. 只能重载已经存在的运算符，只能对一个类或枚举的类型做重载运算符，必须保留原有的操作数的个数，必须保留原有的优先级。
2. 使用关键字`operator`+`+/-/*`表示该类的运算符重载，如`const String String::operator+(const String& that);`，因为已经有一个
    隐藏参数`this`，所以只需要一个参数，如果是全局函数，则需要给出全部参数。返回类型为`const`保证运算结果不会做左值，也可以在函数
    后面加`const`保证`this`指向的对象不会被修改。
3. `x + y`x和y均为对象，左边的运算符为receiver，因此实际发生的事情是`x.operator+(y)`。
4. 如果发生`z = x + 3;`这样的语句，x为receiver，所以调用了x的加法重载函数，编译器会用3来构造一个和x同类型的对象，再与x相加。
5. 如`z = 3 + x`，如果重载运算符函数是成员函数则不行，因为3为receiver，无法将对象x转化为`int`类型。但是如果重载运算符函数是全局函数，
    则编译器会判断虽然x不能转化成3，3却可以转化为x类型，所有可以成功。
6. 单目运算符应该（非强制）做成成员函数，`=()[]->->*`必须做成成员函数。其他可以做成全局函数。
7. 一些原型：

    ```c++
    +-*/%^&|~
    const T operatorX(const T& l, const T& r) const;
    ! && || < <= == >= >
    bool operatorX(const T& l, const T& r) const;
    []
    T& T::operator[](int index);
    class Integer
    {
    public:
        ...
        const Integer& operator++();
        const Integer operator++(int);
        const Integer& operator--();
        const Integer operator--(int);
        ...
    }
    ```

8. 同类对象的赋值，和拷贝构造时是一样的，会对每个成员变量赋值(memberwise)，赋值重载形式如下：

    ```c++
    T& T::operator=(const T& rhs)
    {
        if (this != &rhs)
        {
            //perform assignmen;
        }
        return *this;
    }
    ```

9. 凡是包含动态分配成员或包含指针的类都应该提供拷贝构造函数，还应该考虑重载运算符`'='`。
10. 当用对象A的对象给对象B赋值时，会先调用B的以A为对象的构造函数来构造一个临时B类对象，然后用临时对象来赋值，赋值完成后，
    临时对象就会被析构。总之，编译器会查看是否能做类型转换。
11. explicit: 显式：只能做显式的对象初始化，不能让编译器自动类型转换。显式的构造函数只能在初始化的时候构造，而不能用作赋值时
    类型转换时的构造，即第10条的用法失效。
12. 类型转换，定义形式为：

    ```c++
    class A
    {
        operator T();
    }
    ```

    类型转换函数，可以将A的对象转换为T类对象。尽量不要使用，因为是隐式的，容易被编译器误解。

## 模板(Template)

1. 模板分类模板和函数模板。
2. 模板是一个声明，编译器根据函数模板的声明和使用时的参数类型来制造一个模板函数，有不同参数表类型的模板函数构成重载。

## 异常(Exception)

## 流(Stream)

1. 缺点：啰嗦(verbose)，运行慢。
2. `<<`: Inserter，`>>`: Extractor，
3. cin/cout: 标准输入/输出流，cerr/clog: 标准错误/日志，
4. tab,endl...: manipulator，实质为函数。

## 标准模板库(STL)

1. 容器(Container)，算法(Algorithm)，迭代器(Iterator)。
